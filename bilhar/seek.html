<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Billiards Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: #222;
        }
        #canvas {
            background: #075e07;
            border: 8px solid #654321;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #instructions {
            color: white;
            margin-top: 15px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="500"></canvas>
    <div id="instructions">Click and drag from the white ball to aim, release to shoot</div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "matter": "https://unpkg.com/matter-js@0.14.2/build/matter.min.js"
            }
        }
    </script>
    <script type="module">
        import * as matter from 'matter';

        const { Engine, Bodies, World, Body } = Matter;

        // Constants (standard values)
        const BALL_RADIUS = 15;
        const FRICTION = 0.05;
        const RESTITUTION = 0.9;
        const FRICTION_AIR = 0.005;
        const FORCE_MULTIPLIER = 0.08;
        const MIN_FORCE = 0.5;

        // Set up the canvas and context
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Create the Matter.js engine with better collision detection
        const engine = Engine.create({
            enableSleeping: true,
            gravity: { x: 0, y: 0 }
        });
        engine.world.gravity.y = 0;

        // Helper function to check if balls overlap during random placement
        function isPositionValid(x, y, balls, radius) {
            for (const ball of balls) {
                const dx = ball.x - x;
                const dy = ball.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < radius * 2) {
                    return false;
                }
            }
            return true;
        }

        // Create the balls with random positions (ensuring no overlap)
        const balls = [
            { x: 200, y: 250, color: 'white', radius: BALL_RADIUS, isCueBall: true }, // Cue ball at fixed starting position
            { x: 0, y: 0, color: 'black', radius: BALL_RADIUS }, // Will be positioned randomly
            { x: 0, y: 0, color: 'blue', radius: BALL_RADIUS }    // Will be positioned randomly
        ];

        // Randomize positions for non-cue balls (avoiding overlap)
        for (let i = 1; i < balls.length; i++) {
            let validPosition = false;
            let attempts = 0;
            const maxAttempts = 100;
            
            while (!validPosition && attempts < maxAttempts) {
                balls[i].x = Math.random() * (canvas.width - 100) + 50;
                balls[i].y = Math.random() * (canvas.height - 100) + 50;
                
                validPosition = isPositionValid(balls[i].x, balls[i].y, balls.slice(0, i), BALL_RADIUS);
                attempts++;
            }
        }

        // Create the bodies for the balls with physics properties
        const bodies = balls.map((ball) => {
            return Bodies.circle(ball.x, ball.y, ball.radius, {
                restitution: RESTITUTION,
                friction: FRICTION,
                frictionAir: FRICTION_AIR,
                density: 0.2,
                render: {
                    fillStyle: ball.color,
                    strokeStyle: '#000',
                    lineWidth: 2
                },
                slop: 0.05 // Helps with collision resolution
            });
        });

        // Create the walls (with inward collision edges)
        const wallThickness = 20;
        const wallOptions = { 
            isStatic: true, 
            restitution: 0.8,
            render: { fillStyle: '#654321' }
        };
        
        const walls = [
            // Top wall
            Bodies.rectangle(canvas.width/2, -wallThickness/2, canvas.width, wallThickness, wallOptions),
            // Bottom wall
            Bodies.rectangle(canvas.width/2, canvas.height + wallThickness/2, canvas.width, wallThickness, wallOptions),
            // Left wall
            Bodies.rectangle(-wallThickness/2, canvas.height/2, wallThickness, canvas.height, wallOptions),
            // Right wall
            Bodies.rectangle(canvas.width + wallThickness/2, canvas.height/2, wallThickness, canvas.height, wallOptions)
        ];

        // Add all bodies to the world
        World.add(engine.world, [...bodies, ...walls]);

        // Mouse interaction variables
        let isAiming = false;
        let cueStartPos = null;
        let cueEndPos = null;
        let selectedBall = null;

        // Function to get speed of a body
        function getBodySpeed(body) {
            return Matter.Vector.magnitude(body.velocity);
        }

        // Event listeners for mouse interaction
        canvas.addEventListener('mousedown', (e) => {
            const mousePos = { x: e.offsetX, y: e.offsetY };
            
            // Check if clicking on the cue ball (white ball)
            const cueBall = bodies[0];
            const distance = Matter.Vector.magnitude(Matter.Vector.sub(mousePos, cueBall.position));
            
            if (distance < BALL_RADIUS && getBodySpeed(cueBall) < 0.5) {
                isAiming = true;
                selectedBall = cueBall;
                cueStartPos = mousePos;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isAiming) {
                cueEndPos = { x: e.offsetX, y: e.offsetY };
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (isAiming && selectedBall) {
                cueEndPos = { x: e.offsetX, y: e.offsetY };
                
                // Calculate force vector (direction from mouse release to start position)
                const forceVector = Matter.Vector.sub(cueStartPos, cueEndPos);
                const forceMagnitude = Matter.Vector.magnitude(forceVector) * FORCE_MULTIPLIER;
                
                // Apply minimum force threshold
                if (forceMagnitude > MIN_FORCE) {
                    const normalizedForce = Matter.Vector.normalise(forceVector);
                    const appliedForce = Matter.Vector.mult(normalizedForce, forceMagnitude);
                    
                    // Apply force at the ball's position
                    Body.applyForce(selectedBall, selectedBall.position, appliedForce);
                }
                
                isAiming = false;
                cueStartPos = null;
                cueEndPos = null;
            }
        });

        // Main render function
        function render() {
            // Update the engine
            Engine.update(engine, 1000 / 60);
            
            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw the table felt with a gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#075e07');
            gradient.addColorStop(1, '#0a7a0a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw the walls
            ctx.fillStyle = '#654321';
            for (const wall of walls) {
                ctx.beginPath();
                const vertices = wall.vertices;
                ctx.moveTo(vertices[0].x, vertices[0].y);
                for (let j = 1; j < vertices.length; j++) {
                    ctx.lineTo(vertices[j].x, vertices[j].y);
                }
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw the balls
            for (let i = 0; i < bodies.length; i++) {
                const body = bodies[i];
                if (!body.render.visible) continue;
                
                ctx.beginPath();
                ctx.arc(body.position.x, body.position.y, balls[i].radius, 0, Math.PI * 2);
                ctx.fillStyle = balls[i].color;
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Add a shiny highlight to balls
                if (balls[i].color !== 'black') {
                    ctx.beginPath();
                    ctx.arc(
                        body.position.x - balls[i].radius * 0.3, 
                        body.position.y - balls[i].radius * 0.3, 
                        balls[i].radius * 0.2, 
                        0, 
                        Math.PI * 2
                    );
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
            }
            
            // Draw the aiming cue
            if (isAiming && cueStartPos && cueEndPos) {
                ctx.beginPath();
                ctx.moveTo(cueStartPos.x, cueStartPos.y);
                ctx.lineTo(cueEndPos.x, cueEndPos.y);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw force magnitude indicator
                const force = Matter.Vector.magnitude(Matter.Vector.sub(cueStartPos, cueEndPos)) * FORCE_MULTIPLIER;
                ctx.fillStyle = `hsl(${Math.min(force * 5, 120)}, 100%, 50%)`;
                ctx.fillRect(canvas.width - 120, 20, Math.min(force, 100), 20);
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(canvas.width - 120, 20, 100, 20);
                ctx.fillStyle = '#fff';
                ctx.font = '12px Arial';
                ctx.fillText(`Power: ${force.toFixed(1)}`, canvas.width - 115, 35);
            }
            
            // Request next frame
            requestAnimationFrame(render);
        }

        // Start the render loop
        render();
    </script>
</body>
</html>