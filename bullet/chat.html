<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>9mm Bullet Simulation</title>
  <style>
    body {
      margin: 0;
      background-color: #1e1e2f;
      font-family: sans-serif;
      color: white;
      overflow: hidden;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 8px;
    }
    label {
      display: block;
      margin-top: 5px;
    }
  </style>
</head>
<body>
<canvas id="canvas" width="1000" height="600"></canvas>
<div id="controls">
  <label>Bullet Velocity (m/s):
    <input type="number" id="velocity" value="400" min="10" max="1000">
  </label>
  <label>Wall Thickness (cm):
    <input type="number" id="wallThickness" value="30" min="5" max="100">
  </label>
  <button id="runSimulation">Fire Bullet</button>
  <p id="info">Penetration: 0 cm</p>
</div>

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

<script type="module">

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const velocityInput = document.getElementById('velocity');
const thicknessInput = document.getElementById('wallThickness');
const runBtn = document.getElementById('runSimulation');
const info = document.getElementById('info');

const engine = Matter.Engine.create();
const world = engine.world;

let bullet = null;
let wall = null;
let initialX = 0;

const bulletRadius = 4.5; // 9mm / 2
const pixelsPerCm = 10;   // scaling factor
let penetrationDepth = 0;

// Create wall using user-defined thickness
function createWall(thicknessCm) {
  const wallWidth = thicknessCm * pixelsPerCm;
  const wallX = 800;
  const wallY = canvas.height / 2;
  const wallHeight = 300;

  return Matter.Bodies.rectangle(wallX, wallY, wallWidth, wallHeight, {
    isStatic: true,
    label: 'wall',
    render: { fillStyle: '#888', strokeStyle: '#aaa', lineWidth: 2 }
  });
}

// Create a bullet with physical mass and velocity
function createBullet(initialVelocity) {
  const startX = 100;
  const startY = canvas.height / 2;
  const body = Matter.Bodies.circle(startX, startY, bulletRadius, {
    density: 0.05,
    frictionAir: 0.002,
    restitution: 0.1,
    label: 'bullet',
    render: {
      fillStyle: '#ffcc00',
      strokeStyle: '#000',
      lineWidth: 1
    }
  });

  Matter.Body.setVelocity(body, { x: initialVelocity / 10, y: 0 }); // scale for sim
  return body;
}

function resetSimulation() {
  Matter.World.clear(world);
  Matter.Engine.clear(engine);

  const velocity = parseFloat(velocityInput.value);
  const thickness = parseFloat(thicknessInput.value);

  wall = createWall(thickness);
  bullet = createBullet(velocity);
  initialX = bullet.position.x;

  Matter.World.add(world, [bullet, wall]);
  penetrationDepth = 0;
  info.textContent = 'Penetration: 0 cm';
}

function update() {
  Matter.Engine.update(engine, 1000 / 60);

  if (bullet && wall) {
    const wallLeft = wall.position.x - wall.bounds.max.x + wall.position.x;
    const bulletRight = bullet.position.x + bulletRadius;

    if (bulletRight >= wallLeft) {
      // Estimate impact force
      const relativeVelocity = bullet.velocity.x;
      const wallThickness = parseFloat(thicknessInput.value);
      const mass = bullet.mass;

      const force = 0.5 * mass * relativeVelocity * relativeVelocity;

      const penetrationThreshold = 500; // arbitrary value
      if (force > penetrationThreshold) {
        // Simulate penetration by decreasing velocity
        bullet.velocity.x *= 0.95;
        penetrationDepth = Math.min(
          (bullet.position.x - wall.position.x + wall.bounds.max.x - wall.position.x) / pixelsPerCm,
          wallThickness
        );
      } else {
        bullet.velocity.x *= 0.90;
      }

      info.textContent = `Penetration: ${penetrationDepth.toFixed(1)} cm`;
    }
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw bullet
  ctx.beginPath();
  ctx.arc(bullet.position.x, bullet.position.y, bulletRadius, 0, 2 * Math.PI);
  ctx.fillStyle = bullet.render.fillStyle;
  ctx.fill();
  ctx.strokeStyle = bullet.render.strokeStyle;
  ctx.lineWidth = bullet.render.lineWidth;
  ctx.stroke();

  // Draw wall
  const wallWidth = wall.bounds.max.x - wall.bounds.min.x;
  const wallHeight = wall.bounds.max.y - wall.bounds.min.y;
  ctx.beginPath();
  ctx.rect(wall.position.x - wallWidth / 2, wall.position.y - wallHeight / 2, wallWidth, wallHeight);
  ctx.fillStyle = wall.render.fillStyle;
  ctx.fill();
  ctx.strokeStyle = wall.render.strokeStyle;
  ctx.lineWidth = wall.render.lineWidth;
  ctx.stroke();
}

function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

runBtn.addEventListener('click', () => {
  resetSimulation();
});

resetSimulation();
loop();

</script>
</body>
</html>
